/**
DO NOT EDIT THIS FILE!

It should be only used as a template for creating new ray-marcher.
*/

#define MAX_STEPS 100
#define MAX_DIST 100.
#define SURF_DIST .001
#define PI 3.14159265
#define NUM_OCTAVES 5

precision highp float;

varying vec2 uv;

uniform float uTick;
uniform float uAspectRatio;
uniform vec2 uMouse;
uniform vec2 uResolution;

// helper utitlity functions

mat2 rotate(float angle) {
  float s = sin(angle);
  float c = cos(angle);
  return mat2(c, -s, s, c);
}

vec3 hsv2rgb(vec3 c) {
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

// noise
float rand(vec2 n) {
  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
}

float noise(vec2 p) {
  vec2 ip = floor(p);
  vec2 u = fract(p);
  u = u * u * (3.0 - 2.0 * u);

  float res = mix(mix(rand(ip), rand(ip + vec2(1.0, 0.0)), u.x), mix(rand(ip + vec2(0.0, 1.0)), rand(ip + vec2(1.0, 1.0)), u.x), u.y);
  return res * res;
}

float fbm(vec2 x) {
  float v = 0.0;
  float a = 0.5;
  vec2 shift = vec2(100);
  // Rotate to reduce axial bias
  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
  for(int i = 0; i < NUM_OCTAVES; ++i) {
    v += a * noise(x);
    x = rot * x * 2.0 + shift;
    a *= 0.5;
  }
  return v;
}

// smooth min functions

float smin(float a, float b, float k) {
  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}

// sdf

float sdBox(vec3 point, vec3 size) {
  point = abs(point) - size;
  return length(max(point, 0.)) + min(max(point.x, max(point.y, point.z)), 0.);
}

float sdMandelbulb(vec3 position) {
  vec3 z = position;
  float dr = 1.0;
  float r = 0.0;
  int iterations = 0;
  // float power = 8.0 + (5.0 * map(sin(uTick * 0.005), -1.0, 1.0, 0.0, 1.0));
  float power = mix(8.0, 10.0, sin(uTick * 0.01) * sin(uTick * 0.01));

  for(int i = 0; i < 10; i++) {
    iterations = i;
    r = length(z);

    if(r > 2.0) {
      break;
    }

    // convert to polar coordinates
    float theta = acos(z.z / r);
    float phi = atan(z.y, z.x);
    dr = pow(r, power - 1.0) * power * dr + 1.0;

    // scale and rotate the point
    float zr = pow(r, power);
    theta = theta * power;
    phi = phi * power;

    // convert back to cartesian coordinates
    z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
    z += position;
  }
  float dst = 0.5 * log(r) * r / dr;
  return dst;
}

// ray march functions

float getDistance(vec3 point) {
  // float d = sdBox(point, vec3(1));
  float d = sdMandelbulb(point);
  return d;
}

float rayMarch(vec3 rayOrigin, vec3 rayDirection) {
  float dO = 0.;

  for(int i = 0; i < MAX_STEPS; i++) {
    vec3 point = rayOrigin + rayDirection * dO;
    float dS = getDistance(point);
    dO += dS;
    if(dO > MAX_DIST || abs(dS) < SURF_DIST)
      break;
  }

  return dO;
}

vec3 getNormal(vec3 point) {
  float d = getDistance(point);
  vec2 epsilon = vec2(.001, 0);
  vec3 n = d - vec3(getDistance(point - epsilon.xyy), getDistance(point - epsilon.yxy), getDistance(point - epsilon.yyx));
  return normalize(n);
}

vec3 getRayDirection(vec2 uv, vec3 cameraPosition, vec3 lookatPoint, float zoom) {
  vec3 forward = normalize(lookatPoint - cameraPosition);
  vec3 right = normalize(cross(vec3(0, 1, 0), forward));
  vec3 up = cross(forward, right);
  vec3 center = forward * zoom;
  vec3 pointOnScreen = center + uv.x * right + uv.y * up;
  return normalize(pointOnScreen);
}

void main() {
  vec2 pos = (uv - vec2(0.5)) * vec2(uAspectRatio, 1);
  vec2 mouse = uMouse / uResolution;

  vec3 rayOrigin = vec3(0, 3, -3);
  // rayOrigin.xy *= rotate(mix(-PI / 2.0, PI / 2.0, sin(uTick * 0.01)));
  rayOrigin.xy *= rotate(uTick * 0.01);
  // rayOrigin.zx *= rotate(uTick * 0.001 * PI);
  // rayOrigin.yz *= rotate(-mouse.y * 3.14 + 1. );
  // rayOrigin.xz *= rotate(-mouse.x * 6.2831 + sin(uTick * 0.005));

  vec3 rayDirection = getRayDirection(pos, rayOrigin, vec3(0, 0., 0), mix(1.0, 3.0, sin(uTick * 0.01) * sin(uTick * 0.01)));
  vec3 color = mix(vec3(0.0, 0.0, 0.1), vec3(0.1, 0.0, 0.0), fbm(uv * 2.0 + vec2(uTick * 0.01)));

  float d = rayMarch(rayOrigin, rayDirection);
  float h = 0.5 + uTick * 0.001;
  if(d < MAX_DIST) {
    vec3 p = rayOrigin + rayDirection * d;
    vec3 n = getNormal(p);
    // vec3 r = reflect(rayDirection, n);

    float diffuseLighting = dot(n, normalize(vec3(1, 2, 3))) * .5 + .5;
    vec3 baseColor = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), fbm(p.yz));
    // color = mix(hsv2rgb(vec3(h, 0.5, 1.0)), hsv2rgb(vec3(h + 0.5, 0.8, 0.1)), diffuseLighting);
    color = baseColor * diffuseLighting;
  }

  // gamma correction
  color = pow(color, vec3(.4545));
  // color.r += fbm(uv + sin(uTick * 0.005)) * 1.0;
  // color.g -= fbm(uv - cos(uTick * 0.005)) * 1.0;
  // color.b *= rand(uv) * 1.0;

  gl_FragColor = vec4(color, 1.0);
}